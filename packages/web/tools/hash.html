<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hash 计算 - 拾光工具箱</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/tool.css">
</head>
<body>
  <nav class="nav">
    <div class="container">
      <div class="nav-content">
        <a href="/" class="logo">
          <svg class="icon" viewBox="0 0 24 24"><path d="M20.083 15.2l1.202.721a.5.5 0 0 1 0 .858l-8.77 5.262a1 1 0 0 1-1.03 0l-8.77-5.262a.5.5 0 0 1 0-.858l1.202-.721L12 20.05l8.083-4.85zm0-4.7l1.202.721a.5.5 0 0 1 0 .858L12 17.65l-9.285-5.571a.5.5 0 0 1 0-.858l1.202-.721L12 15.35l8.083-4.85zm-7.569-9.191l8.771 5.262a.5.5 0 0 1 0 .858L12 13 2.715 7.429a.5.5 0 0 1 0-.858l8.77-5.262a1 1 0 0 1 1.03 0z"/></svg>
          <span>拾光工具箱</span>
        </a>
        <button id="themeToggle" class="theme-btn">
          <svg class="icon" viewBox="0 0 24 24"><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7z"/></svg>
        </button>
      </div>
    </div>
  </nav>

  <div class="tool-container">
    <div class="tool-header">
      <h1>
        <svg class="icon" viewBox="0 0 24 24"><path d="M7.784 14l.42-4H4V8h4.415l.525-5h2.011l-.525 5h3.989l.525-5h2.011l-.525 5H20v2h-3.784l-.42 4H20v2h-4.415l-.525 5h-2.011l.525-5H9.585l-.525 5H7.049l.525-5H4v-2h3.784zm2.011 0h3.99l.42-4h-3.99l-.42 4z"/></svg>
        Hash 计算
      </h1>
      <p>计算文本的 MD5、SHA1、SHA256 等哈希值</p>
    </div>

    <div class="tool-card">
      <div class="card-header">输入文本</div>
      <textarea id="input" class="code-input" placeholder="输入要计算哈希值的文本" oninput="calculateHash()"></textarea>
    </div>

    <div class="tool-card">
      <div class="card-header">哈希结果</div>
      <div class="hash-results">
        <div class="hash-row">
          <span class="hash-label">MD5 (32位)</span>
          <input type="text" id="md5" class="hash-value" readonly>
          <button class="btn-sm" onclick="copyHash('md5')">复制</button>
        </div>
        <div class="hash-row">
          <span class="hash-label">SHA-1</span>
          <input type="text" id="sha1" class="hash-value" readonly>
          <button class="btn-sm" onclick="copyHash('sha1')">复制</button>
        </div>
        <div class="hash-row">
          <span class="hash-label">SHA-256</span>
          <input type="text" id="sha256" class="hash-value" readonly>
          <button class="btn-sm" onclick="copyHash('sha256')">复制</button>
        </div>
        <div class="hash-row">
          <span class="hash-label">SHA-512</span>
          <input type="text" id="sha512" class="hash-value" readonly>
          <button class="btn-sm" onclick="copyHash('sha512')">复制</button>
        </div>
      </div>
    </div>

    <div class="tool-card">
      <div class="card-header">大小写</div>
      <div class="btn-group">
        <button class="btn" id="btnLower" onclick="setCase('lower')">小写</button>
        <button class="btn btn-primary" id="btnUpper" onclick="setCase('upper')">大写</button>
      </div>
    </div>
  </div>

  <script src="/js/config.js"></script>
  <script>
    let upperCase = true;

    // MD5 算法实现
    function md5(string) {
      function rotateLeft(value, shift) {
        return (value << shift) | (value >>> (32 - shift));
      }

      function addUnsigned(x, y) {
        return ((x & 0x7FFFFFFF) + (y & 0x7FFFFFFF)) ^ (x & 0x80000000) ^ (y & 0x80000000);
      }

      function F(x, y, z) { return (x & y) | ((~x) & z); }
      function G(x, y, z) { return (x & z) | (y & (~z)); }
      function H(x, y, z) { return x ^ y ^ z; }
      function I(x, y, z) { return y ^ (x | (~z)); }

      function FF(a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(F(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
      }

      function GG(a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(G(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
      }

      function HH(a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(H(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
      }

      function II(a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(I(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
      }

      function convertToWordArray(str) {
        let wordCount;
        const msgLen = str.length;
        const tempA = msgLen + 8;
        const tempB = (tempA - (tempA % 64)) / 64;
        const wordArrayLen = (tempB + 1) * 16;
        const wordArray = Array(wordArrayLen - 1);
        let bytePos = 0;
        let byteCount = 0;
        while (byteCount < msgLen) {
          wordCount = (byteCount - (byteCount % 4)) / 4;
          bytePos = (byteCount % 4) * 8;
          wordArray[wordCount] = (wordArray[wordCount] || 0) | (str.charCodeAt(byteCount) << bytePos);
          byteCount++;
        }
        wordCount = (byteCount - (byteCount % 4)) / 4;
        bytePos = (byteCount % 4) * 8;
        wordArray[wordCount] = (wordArray[wordCount] || 0) | (0x80 << bytePos);
        wordArray[wordArrayLen - 2] = msgLen << 3;
        wordArray[wordArrayLen - 1] = msgLen >>> 29;
        return wordArray;
      }

      function wordToHex(value) {
        let hex = '', temp, byte;
        for (byte = 0; byte <= 3; byte++) {
          temp = (value >>> (byte * 8)) & 255;
          hex += ('0' + temp.toString(16)).slice(-2);
        }
        return hex;
      }

      const utf8Str = unescape(encodeURIComponent(string));
      const x = convertToWordArray(utf8Str);
      let a = 0x67452301, b = 0xEFCDAB89, c = 0x98BADCFE, d = 0x10325476;
      const S11 = 7, S12 = 12, S13 = 17, S14 = 22;
      const S21 = 5, S22 = 9, S23 = 14, S24 = 20;
      const S31 = 4, S32 = 11, S33 = 16, S34 = 23;
      const S41 = 6, S42 = 10, S43 = 15, S44 = 21;

      for (let k = 0; k < x.length; k += 16) {
        const AA = a, BB = b, CC = c, DD = d;
        a = FF(a, b, c, d, x[k], S11, 0xD76AA478);
        d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
        c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
        b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
        a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
        d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
        c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
        b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
        a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
        d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
        c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
        b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
        a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
        d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
        c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
        b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
        a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
        d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
        c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
        b = GG(b, c, d, a, x[k], S24, 0xE9B6C7AA);
        a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
        d = GG(d, a, b, c, x[k + 10], S22, 0x02441453);
        c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
        b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
        a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
        d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
        c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
        b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
        a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
        d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
        c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
        b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
        a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
        d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
        c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
        b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
        a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
        d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
        c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
        b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
        a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
        d = HH(d, a, b, c, x[k], S32, 0xEAA127FA);
        c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
        b = HH(b, c, d, a, x[k + 6], S34, 0x04881D05);
        a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
        d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
        c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
        b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
        a = II(a, b, c, d, x[k], S41, 0xF4292244);
        d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
        c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
        b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
        a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
        d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
        c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
        b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
        a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
        d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
        c = II(c, d, a, b, x[k + 6], S43, 0xA3014314);
        b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
        a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
        d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
        c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
        b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
        a = addUnsigned(a, AA);
        b = addUnsigned(b, BB);
        c = addUnsigned(c, CC);
        d = addUnsigned(d, DD);
      }
      return wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);
    }

    // SHA 使用 Web Crypto API
    async function sha(algorithm, message) {
      const encoder = new TextEncoder();
      const data = encoder.encode(message);
      const hash = await crypto.subtle.digest(algorithm, data);
      const hashArray = Array.from(new Uint8Array(hash));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async function calculateHash() {
      const text = document.getElementById('input').value;
      if (!text) {
        document.getElementById('md5').value = '';
        document.getElementById('sha1').value = '';
        document.getElementById('sha256').value = '';
        document.getElementById('sha512').value = '';
        return;
      }

      const md5Hash = md5(text);
      const sha1Hash = await sha('SHA-1', text);
      const sha256Hash = await sha('SHA-256', text);
      const sha512Hash = await sha('SHA-512', text);

      document.getElementById('md5').value = upperCase ? md5Hash.toUpperCase() : md5Hash;
      document.getElementById('sha1').value = upperCase ? sha1Hash.toUpperCase() : sha1Hash;
      document.getElementById('sha256').value = upperCase ? sha256Hash.toUpperCase() : sha256Hash;
      document.getElementById('sha512').value = upperCase ? sha512Hash.toUpperCase() : sha512Hash;
    }

    function setCase(c) {
      upperCase = c === 'upper';
      document.getElementById('btnLower').className = upperCase ? 'btn' : 'btn btn-primary';
      document.getElementById('btnUpper').className = upperCase ? 'btn btn-primary' : 'btn';
      calculateHash();
    }

    function copyHash(id) {
      const value = document.getElementById(id).value;
      if (!value) return;
      navigator.clipboard.writeText(value);
      showToast('已复制');
    }

    function showToast(msg) {
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.textContent = msg;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 2000);
    }
  </script>
</body>
</html>
